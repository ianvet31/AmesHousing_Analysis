---
title: "Data Analysis - Ames House Prices"
author: "Random85"
date: "2023-07-20"
output:
  pdf_document: default
  html_document: default
---

# The Dataset

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r, warning=FALSE}
library(faraway)
library(dplyr)
library(psych)
library(corrplot)
library(ggplot2)
library(ggcorrplot)
library(lares)
library(reshape2)

housing_data = read.csv("dataset\\AmesHousing.csv")

# summary(housing_data)

nrow(housing_data)
ncol(housing_data)

# Using small chunk of dataset for quick testing :)

#housing_data = housing_data[1:100,]

# Coercing categorical predictors into factor variables

housing_data[is.na(housing_data)] = 1

for (i in 1:ncol(housing_data)) {
  if (typeof(housing_data[, i]) == "character") {
    if (length(unique(housing_data[, i])) >= 2) {
      housing_data[, i] = as.factor(housing_data[, i])
    }
    
  }
}

housing_data$Yr.Sold = as.factor(housing_data$Yr.Sold)

str(housing_data)
```

First few examples:

```{r}
housing_data$SalePrice[1:10]
housing_data$Lot.Area[1:10]
housing_data$Utilities[1:10]
```


Dropping some of the columns that are not useful as a predictor for sale price.

```{r}
# Dropping the order and PID, looks like this is just for record keeping
housing_data = subset(housing_data, select = -c(Order, PID))

# Removing lot fraontage area, since we have lot area. Frontage is measurement of the house start to the street. It has way more null values
housing_data = subset(housing_data, select = -c(Lot.Frontage))

# Removing alley because we have street data
housing_data = subset(housing_data, select = -c(Alley))

# removing one condition column and exterior
housing_data = subset(housing_data, select = -c(Condition.2, Exterior.2nd))

```

```{r, eval=FALSE}
View(housing_data)
```



# Collinearity and correlation analysis


```{r}

# Subsetting all the numeric elements of the dataset for collinearity and correlation analysis:

n_idxs = unlist(lapply(housing_data, is.numeric), use.names = FALSE)  
all_numeric_housing_data = housing_data[, n_idxs]
numeric_housing_data = subset(all_numeric_housing_data, select = -c(SalePrice))

#str(numeric_housing_data)



# MUST specify use = "complete.obs" argument to ignore NA's in dataset
corrs = round(cor(numeric_housing_data, use="complete.obs"), 2)


# some possible correlation plots?

#corrplot(corrs, method="number")
#ggcorrplot(corrs, lab_size = 0.1)

#corrs

ggplot(melt(corrs), aes(Var1, Var2, fill=value)) +
  geom_tile(height=0.9, width=0.9) +
  scale_fill_gradient2(low="blue", mid="white", high="red") +
  theme_minimal() +
  coord_equal() +
  labs(x="",y="",fill="Corr") +
  theme(axis.text.x=element_text(size=5, angle=45, vjust=1, hjust=1, 
                                 margin=margin(-3,0,0,0)),
        axis.text.y=element_text(size=5, margin=margin(0,-3,0,0)),
        panel.grid.major=element_blank()) 

```

Taking a closer look at some of the most correlated predictors:

```{r}

corr_cross(numeric_housing_data,
  max_pvalue = 0.05,
  top = 15 
)

# A few of these further visualized in pairs:
names(numeric_housing_data)

# pairs(numeric_housing_data, col = "dodgerblue")
```

While some of these high correlation measures are to be expected, such as house year built along garage year built, we can also see some non-trivial patterns start to emerge from the more continuous numeric predictors.


# Models (VP)

```{r}
#Functions to evaluate models
library(lmtest)

get_bp_decision = function(model, alpha) {
  decide = unname(bptest(model)$p.value < alpha)
  ifelse(decide, "Reject", "Fail to Reject")
}

get_sw_decision = function(model, alpha) {
  decide = unname(shapiro.test(resid(model))$p.value < alpha)
  ifelse(decide, "Reject", "Fail to Reject")
}

get_num_params = function(model) {
  length(coef(model))
}

get_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2,na.rm=TRUE))
}

get_adj_r2 = function(model) {
  summary(model)$adj.r.squared
}
```



### Location of the house could play a big role in house price, but for the dataset that is used, it has total 28 neighbors as follow:

```{r}
length(unique(housing_data[, "Neighborhood"]))
```

### We don't need this big list of dummy variable, so creating new variable as location based on some important factor

```{r}
# first converting the some exterior variables to numeric and then using it:
levels(housing_data[,"Exter.Cond"])
levels(housing_data[,"Exter.Qual"])
levels(housing_data[,"Functional"])

housing_data$Exter.Cond.Num = 5 - as.numeric(housing_data[, "Exter.Cond"])
housing_data$Exter.Qual.Num = 4 - as.numeric(housing_data[, "Exter.Qual"])
housing_data$Functional.Num = ifelse(housing_data[,"Functional"] == "Maj1", 8, 
                                     ifelse(housing_data[,"Functional"] == "Maj2", 7, 
                                            ifelse(housing_data[,"Functional"] == "Min1", 6,
                                                   ifelse(housing_data[,"Functional"] == "Min2", 5, 
                                                          ifelse(housing_data[,"Functional"] == "Mod", 4,
                                                                 ifelse(housing_data[,"Functional"] == "Typ", 3,
                                                                        ifelse(housing_data[,"Functional"] == "Sev", 2,
                                                                               ifelse(housing_data[,"Functional"] == "Sal", 1, 0))))))))

housing_data$Location = (housing_data[,"Overall.Qual"] / mean(housing_data[,"Overall.Qual"])) +
                        (housing_data[,"Overall.Cond"] / mean(housing_data[,"Overall.Cond"])) +
                        (housing_data[,"Exter.Cond.Num"] / mean(housing_data[,"Exter.Cond.Num"])) + 
                        (housing_data[,"Exter.Qual.Num"] / mean(housing_data[,"Exter.Qual.Num"])) +
                        (housing_data[,"Functional.Num"] / mean(housing_data[,"Functional.Num"]))

summary(housing_data[,"Location"])
```
### Make sure that location is corelated to saleprice and positive:

```{r}
cor(housing_data[,c("Location","SalePrice")])
```
### It has weak but a positive relation of with saleprice.

### Taking most relevant predictors that are logically be useful to build saleprice model with existing knowledge of real estate.
```{r}
# this model removes some of the qualities variable because it has some condition of those variables present
# Such as, keeping Bsmt.Cond and removing Bsmt.Qual (because both factor has almost same levels)

saleprice_full_model_selected = lm(SalePrice ~ MS.Zoning + Lot.Area + Street + Lot.Shape + Land.Contour + Utilities + Lot.Config + Land.Slope + Condition.1  + House.Style + Year.Built + Foundation + Location + Roof.Style + Exterior.1st + Total.Bsmt.SF + Bsmt.Cond + Bsmt.Full.Bath + Heating + Central.Air + Electrical + X1st.Flr.SF + X2nd.Flr.SF + Gr.Liv.Area + Full.Bath + Half.Bath + Bedroom.AbvGr + Kitchen.AbvGr + Kitchen.Qual + TotRms.AbvGrd + Fireplaces + Garage.Area + Paved.Drive + Wood.Deck.SF  + Open.Porch.SF + Pool.Area + Fence + Misc.Val + Mo.Sold + Yr.Sold, data = housing_data)

saleprice_additive_model = lm(SalePrice ~ ., data = housing_data)

saleprice_selected_backward_aic = step(saleprice_full_model_selected, direction = "backward", trace = 0)

```


```{r}
# check the number of predictors in the model
length(coef(saleprice_full_model_selected)) - 1
length(coef(saleprice_selected_backward_aic)) - 1
```

### Testing the built model
```{r}
get_loocv_rmse(saleprice_additive_model)
get_loocv_rmse(saleprice_full_model_selected)
get_loocv_rmse(saleprice_selected_backward_aic)
```
### Even though removing so many variables, the model is still very huge, so, removing some of the variables that are may be corelated. Also, removing the variables that seems related based on the common real estate knowledge.

```{r}

saleprice_full_model_selected_reduced = lm(SalePrice ~ MS.Zoning + Lot.Area + Street + Lot.Shape + Utilities + Land.Slope + House.Style + Year.Built + Foundation + Location + Heating + Central.Air + Electrical + Gr.Liv.Area + Full.Bath + Bedroom.AbvGr + Kitchen.AbvGr + Kitchen.Qual + TotRms.AbvGrd + Fireplaces + Garage.Area + Paved.Drive + Wood.Deck.SF  + Open.Porch.SF + Pool.Area + Fence + Misc.Val + Yr.Sold  , data = housing_data)

saleprice_selected_reduced_backward_aic = step(saleprice_full_model_selected_reduced, direction = "backward", trace = 0)

summary(saleprice_selected_reduced_backward_aic)
```

```{r}
# temp
length(coef(saleprice_full_model_selected_reduced)) - 1
length(coef(saleprice_selected_reduced_backward_aic)) - 1
```

### Testing the built model
```{r}
get_loocv_rmse(saleprice_additive_model)
get_loocv_rmse(saleprice_full_model_selected_reduced)
get_loocv_rmse(saleprice_selected_reduced_backward_aic)
```

```{r}
anova(saleprice_full_model_selected_reduced, saleprice_selected_reduced_backward_aic)
```


# For Transformations analyzing the data

```{r}
par(mfrow = c(2, 2))    

plot(SalePrice ~ Lot.Area, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs Lot area")

plot(SalePrice ~ X1st.Flr.SF, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs First floor area")

plot(SalePrice ~ X2nd.Flr.SF, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs Second floor area")

plot(SalePrice ~ Garage.Area, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs Garage area")
```

```{r}

par(mfrow = c(2, 2))    

plot(SalePrice ~ Total.Bsmt.SF, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs Basement area")

plot(SalePrice ~ Overall.Qual, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs Overall quality")


plot(SalePrice ~ Overall.Cond, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs Overall condition")
```

```{r}

par(mfrow = c(2, 2))   

plot(SalePrice ~ Gr.Liv.Area, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs Living area")

plot(SalePrice ~ Full.Bath, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs # of full bathrooms")

plot(SalePrice ~ MS.SubClass, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs MS Subclass")

plot(SalePrice ~ Wood.Deck.SF, data = housing_data, col = "grey", pch = 20, cex = 1.5,
     main = "Sale price vs Deck area")
```







